//  All objects under this
//  namespace should explicitly depend on jQuery. All objects that are
//  framework independent should be elsewhere (possibly in helpful_routines.js).

var CWjQuery = jQuery.noConflict( );

/**
 * Constants used by Clockwork code; not prefixed by Clockwork
**/

var CW_LOG_ALERT  =  1;
var CW_LOG_CRIT   =  2;
var CW_LOG_ERROR  =  4;
var CW_LOG_WARN   =  8;
var CW_LOG_INFO   =  16;
var CW_LOG_DEBUG  =  32;

var CW_LOG_NONE              =  0;   // Nothing
var CW_LOG_ALL               =  63;  // UPTO DEBUG
var CW_LOG_PRODUCTION_LEVEL  =  7;   // ALERT through ERROR

var CW_LOG_DEFAULT_LEVEL     =  CW_LOG_DEBUG;

var CW = {};

/**
 * Clockwork javascript configuration; all config settings go here.
 *
 * @author Matt Gray <matt@>
**/
CW.config  =  {

	/* Which RTE to use: `tiny_mce' */
	default_editor_type  :  'tiny_mce',

	/** Level at which to display log messages */
	logger_level         :  CW_LOG_PRODUCTION_LEVEL,

	/* Default format for input field date strings */
	date_format                        :  'MM/dd/yyyy',

	/* Default format for input field date & time strings */
	datetime_format                    :  'MM/dd/yyyy h:mm tt',

    /* Format for input field date & time including seconds strings */
	datetime_with_seconds_format       :  'MM/dd/yyyy h:mm:ss tt',

	/* Interval for session timeout activity ping in seconds */
	activity_ping_interval: 45
};


CW.assetGroups = [];

if ( ! String.prototype.toCamelCase ) {
	String.prototype.toCamelCase  =  function( ) {
		return this.replace( /(?:^|\s|\-|_)(\w)/g, function( match ) { return match.toUpperCase( ); } ).replace( /[^A-Za-z0-9]/g, '' );
	}
}

// Dummy Logger if undefined
if ( typeof( Logger ) === "undefined" ) {
	Logger = {};
	Logger.log = function( ) {};
}

(function( $ ){


	/* Convenience function to wrap jQuery's serializeArray() behavior
	 * to flat key:value data suitable for passing to as ajax params.
 	*/
	$.fn.serializeJSON = function() {
		var arrayData, objectData;
		arrayData = this.serializeArray();
		objectData = {};

		$.each(arrayData, function() {
			var value;

			if (this.value != null) {
				value = this.value;
			} else {
				value = '';
			}

			if (objectData[this.name] != null) {
				if (!objectData[this.name].push) {
					objectData[this.name] = [objectData[this.name]];
				}

				objectData[this.name].push(value);
			}
			else {
				objectData[this.name] = value;
			}
		});

		return objectData;
	};
	$.fn.get_component_element_selector = function ( component_id, name ) {
		return '#c_' + component_id + '_' + name;
	};

	$.fn.get_component_element = function ( component_id, name ) {
		return $(this.get_component_element_selector(component_id, name));
	};

})( CWjQuery );


// jQuery.stringify complements jQuery.parseJSON for use in IE<9,
// which has no JSON. (https://gist.github.com/754454/)
CWjQuery.extend({
	stringify  : function stringify(obj) {         
		if ("JSON" in window) {
			return JSON.stringify(obj);
		}

		var t = typeof (obj);
		if (t != "object" || obj === null) {
			// simple data type
			if (t == "string") obj = '"' + obj + '"';

			return String(obj);
		}
		else {
			// recurse array or object
			var n, v, json = [], arr = (obj && obj.constructor == Array);

			for (n in obj) {
				v = obj[n];
				t = typeof(v);
				if (obj.hasOwnProperty(n)) {
					if (t == "string") {
						v = '"' + v + '"';
					}
					else if (t == "object" && v !== null){
						v = jQuery.stringify(v);
					}

					json.push((arr ? "" : '"' + n + '":') + String(v));
				}
			}

			return (arr ? "[" : "{") + String(json) + (arr ? "]" : "}");
		}
	}
});



/**
 * Simple JS Inheritance
 * By John Resig http://ejohn.org/blog/simple-javascript-inheritance/
 * MIT Licensed: http://www.opensource.org/licenses/mit-license.php
 * Inspired by base2 and Prototype
 *
 * Renamed from "Class" to avoid conflicts with Prototype's "Class.create"
**/

(function(){
  var initializing = false, fnTest = /xyz/.test(function(){xyz;}) ? /\b_super\b/ : /.*/;
  // The base CWjQueryClass implementation (does nothing)
  this.CWjQueryClass = function(){};
  
  // Create a new CWjQueryClass that inherits from this class
  CWjQueryClass.extend = function(prop) {
    var _super = this.prototype;
    
    // Instantiate a base class (but only create the instance,
    // don't run the init constructor)
    initializing = true;
    var prototype = new this();
    initializing = false;
    
    // Copy the properties over onto the new prototype
    for (var name in prop) {
      // Check if we're overwriting an existing function
      prototype[name] = typeof prop[name] == "function" && 
        typeof _super[name] == "function" && fnTest.test(prop[name]) ?
        (function(name, fn){
          return function() {
            var tmp = this._super;
            
            // Add a new ._super() method that is the same method
            // but on the super-class
            this._super = _super[name];

            // The method only need to be bound temporarily, so we
            // remove it when we're done executing
            var ret = fn.apply(this, arguments);
            this._super = tmp;

            return ret;
          };
        })(name, prop[name]) :
        prop[name];
    }
    
    // The dummy class constructor
    function CWjQueryClass() {
      // All construction is actually done in the init method
      if ( !initializing && this.init )
        this.init.apply(this, arguments);
    }
    
    // Populate our constructed prototype object
    CWjQueryClass.prototype = prototype;
    
    // Enforce the constructor to be what we expect
    CWjQueryClass.constructor = CWjQueryClass;

    // And make this class extendable
    CWjQueryClass.extend = arguments.callee;
    
    return CWjQueryClass;
  };
})();


/* Update messages using the new Messagebox DIV, etc. */


CW.Analytics  =  {

	event_name: 'cw:analytics-event',

	register_events: function( evts ) {

		if ( evts instanceof Array && evts.length > 0 ) {
			for ( var evt in evts ) {
				var name = evts[ evt ];
				if ( typeof( name ) === "string" ) {
					CWjQuery( document ).trigger( CW.Analytics.event_name, { "name": name } );
				}
			}
		}
	}
}


CW.Message = CWjQueryClass.extend( {

	message_appear_duration: 0.3,

	messagebox: null,

	mini_message_duration: 5,

	ms_fudge: 50,

	options:  {
		show_method: function( messagebox ) {
			messagebox.fadeIn( );
		},

		hide_method: function( messagebox ) {
			messagebox.fadeOut( );
		}
	},

	init: function ( message, message_type, options ) {

		this.message       =  message;
		this.message_type  =  message_type;
		this.options       =  this.options || {};

		// Prototype didn't require the '#' on the target, so
		// we'll just append it if it wasn't passed in
		if ( options.message_target != null && 
				CWjQuery.type(options.message_target) == 'string' &&
				options.message_target.indexOf('#') != 0 ) {
			options.message_target = '#' + options.message_target;
		}

		CWjQuery.extend( this.options, options || {} );

		this.message_details  =  this.options.message_details || [];

		var message_node  =  CWjQuery( this.options.message_target );

		if ( ! message_node ) {
			Logger.log(
				'Cannot find id: ' + ( this.options.message_target ? this.options.message_target : 'messagebox_target' ),
				CW_LOG_DEBUG
			);
			return;
		}

		var clear_node  =  CWjQuery( this.options.clear_target );
		if ( clear_node.length > 0 ) {
			clear_node.empty( );
		}

		/* Clear out the children */
		if ( ! this.options.append ) {
			message_node.empty( );
		}

		clear_node.hide( );
		message_node.hide( );
		this.messagebox  =  this.get_messagebox_element( );

		/* Add the message to the DOM */
		this.messagebox  =  message_node.append( this.messagebox );

		this.options.show_method( this.messagebox );

		/* Mini-messages have duration by default. */
		if ( options.mini_message && ( typeof options.duration == 'undefined' || options.duration === null ) ) {
			options.duration  =  this.mini_message_duration;
		}

		/* If there's a duration on this Message, clean it up! */
		if ( options.duration && message_type != 'error' ) {
			var f  =  CWjQuery.proxy( function( ) {
				this.messagebox && this.remove_message( this.messagebox );
			}, this );
			setTimeout( f, Math.floor( options.duration * 1000 ) );
		}
	},

	remove: function ( ) {

		if ( ! this.messagebox ) {
			return;
		}

		this.remove_message( this.messagebox );
	},

	remove_message: function ( message ) {

		this.options.hide_method( message );

	},

	get_messagebox_element: function ( ) {

		var mb         =  ( this.options.mini_message ) ? document.createElement( 'span' ) : document.createElement( 'div' );
		if ( this.options.message_id ) { mb.id  =  this.options.message_id; }
		mb.className   =  this.options.mini_message ? 'mini_messagebox' : 'messagebox';
		mb.className  +=  ( this.message_type ? ( ' ' + this.message_type ) : '' );

		var h2         =  document.createElement( 'h2' );
		h2.className   =  ( this.message_type ? this.message_type : '' );
		h2.appendChild( document.createTextNode( this.message ) );
		mb.appendChild( h2 );

		/* Draw message details unordered list? */
		var draw_details  =  ( ! this.options.mini_message                       &&
								 this.message_details                            && 
								 typeof( this.message_details ) === typeof( [] ) &&
								 this.message_details.length > 0                    );

		if ( draw_details ) {

			var ul = CWjQuery( '<ul class="'+this.message_type+'"/>');
			CWjQuery(mb).append( ul );

			for (var i=0;i<this.message_details.length;i++) {

				var message_text = '';
				if ( typeof( this.message_details[i] ) == typeof( '') ) {
					message_text = this.message_details[i];
				}
				else if ( typeof( this.message_details[i] ) == typeof( {} ) &&
					 this.message_details[i].error_detail ) {
					message_text = this.message_details[i].error_detail;
				}

				ul.append('<li>' + message_text + '</li>');
			}

			CWjQuery(mb).append( ul );

		}

		return mb;
	}
} );


CW.MiniMessage  =  CW.Message.extend( {

	init: function ( message, message_type, options ) {
		options.mini_message = true;
		this._super( message, message_type, options );
	}
});



CW.AjaxRequest  =  CWjQueryClass.extend( {

	results: {},

	current_xhr : null,

	/**
	 * options:
	 *   onComplete: function
	 *   use_get: bool
	 *   message_target: string
	 *   show_message: function - returns true or false
	 *   mini_message: bool
	 *   duration: time
	**/
	init : function ( url, options ) {

		var effective_options  =  {
			'show_message' : function( ) { return true; }
		};

		CWjQuery.extend( effective_options, options || { } );

		effective_options.json  =  1;

		// Prototype backwards compatibility. If they've included a 'parameters' property on the 
		// options, we would have moved those to '__querystring_params' in the convertPrototypeOptionsTojQuery
		// function call. If we find that string here, lets append it to the url
		var effective_url  =  url;
		if ( effective_options.hasOwnProperty( '__querystring_params' ) && effective_options.__querystring_params != null ) {
			effective_url = effective_url + (url.indexOf('?') > -1 ? '&' : '?') + effective_options.__querystring_params;
			delete effective_options['__querystring_params'];
		}

		// If no sync/async option is set, lets default it to be asynchronous
		if ( ! effective_options.hasOwnProperty( "asynchronous" ) || effective_options.asynchronous == null ) {
			effective_options.asynchronous  =  true;
		}

		this.results  =  { };

		var onComplete  =  CWjQuery.proxy( function ( jsondata, response_status, XHR ) {
			this.current_xhr = XHR;
			this.handleResponse( jsondata, response_status, XHR );
			if ( this.options.onComplete ) {
				this.options.onComplete( this.results );
			}
		},  this );

		var onError  =  CWjQuery.proxy( function ( XHR, response_status, errorThrown ) {
			this.current_xhr = XHR;
			this.handleError( XHR, response_status, errorThrown );
			if ( this.options.onComplete ) {
				this.options.onComplete( this.results );
			}
		},  this );


		this.options = effective_options;

		request_params = this.remove_functions( effective_options );

		// If this is false, jQuery.post will attempt to serialize nested data in effective_options,
		// which can crash google Chrome.
		CWjQuery.ajaxSetup( {'traditional':true} );

		var method = this.options.use_get ? 'get' : 'post';

		this.current_xhr = CWjQuery.ajax( effective_url, {
				type: method,
				async: this.options.asynchronous,
				data: request_params,
				success: onComplete,
				error: onError
				});
	},


	/**
	 * Remove functions from a request object. 
	 * If not removed, functions (like onComplete) will be 
	 * evaluated by jQuery's http param serialization.
	 *
	 * * @author Lloyd Dalton <lloyd@clockwork.net>
	 * * 
	 * * @param   {}  data
	 * * @return  []
	 ***/

	remove_functions : function( data ) {

		if ( typeof( data ) != 'object' ) {
			return data;
		}

		request_params = {};

		for( var k in data ) {

			var t = typeof( data[k] );

			if ( t == "function" ) {
				continue;
			}
			request_params[k] = data[k];
		}

		return request_params;
	},


	handleResponse : function ( jsondata, response_status, XHR ) {
		this.processResponse( jsondata, response_status, XHR );
		this.displayMessage( );
		this.setFieldStyles( this.results.fields );
	},

	handleError : function ( XHR, response_status, errorThrown ) {
		if ( response_status == 'abort' ) {
			return;
		}

		Logger.log( 'Response not a success, status: '+response_status + ', HTTP status' + errorThrown, CW_LOG_DEBUG );

		this.results.error = true;
		this.results.message = 'Request Failed';
		this.results.message_type = 'error';
		this.displayMessage( );

	},

	parseJsonString: function ( json ) {
		try {
			return JSON.parse( json );
		}
		catch ( e ) {
			Logger.log( 'Invalid json', CW_LOG_DEBUG );
			return null;
		}
	},

	processResponse:  function ( jsondata, response_status, XHR ) {

		if ( response_status != 'success' ) {
			Logger.log( 'Response not a success, status: '+response_status, CW_LOG_DEBUG );
            this.results.error = true;
            this.results.message = 'Request Failed';
            this.results.message_type = 'error';
			return;
		}

		var content_type  =  XHR.getResponseHeader('content-type');
		content_type  =  content_type.replace( /;.*$/, '' );


		// We need to handle xml in AjaxRequest, even though we're hardcoding json = 1
		// during init. Some server actions don't even look at the json|xml setting 
		// and just return xml anyways.
		if ( content_type == "text/xml" ) {

			var xml = jsondata;

			if ( xml != null ) {

				/* XML parse error, possibly caused by leading or trailing newline or whitespace in a php file */
				if ( xml.firstChild.tagName == 'parsererror' ) {

					this.results.message       =  'Error parsing xml response';
					this.results.message_type  =  'error';
					return;
				}
				
				this.results.output        =  this.getTagContent( xml, 'output' );
				this.results.message       =  this.getTagContent( xml, 'message' );
				this.results.extra_data    =  this.getTagContent( xml, 'extra-data' );
				this.results.message_type  =  this.getTagAttribute( xml, 'message', 'type' );
				this.results.error         =  parseInt( this.getTagContent( xml,'error' ) );

			} else {
				
				this.results.error = 1;
				this.results.message = 'Error - null responseXML';
				this.results.message_type = 'error';
			}

		}
		else {

			if ( typeof( jsondata ) != typeof( {} ) ) {
				if ( ! ( jsondata = this.parseJsonString( jsondata ) ) ) {
					Logger.log( 'Invalid response', CW_LOG_DEBUG );
					this.results.error = true;
					this.results.message = 'Request Failed - invalid response';
					this.results.message_type = 'error';
					return;
				}
			}

			try {
				this.results.message          =  jsondata.message || '';
				this.results.message_type     =  jsondata.message_type;
				this.results.error            =  ( jsondata.error == '1' ) ? true : false;
				this.results.extra_data       =  jsondata.extra_data;

				// This is set for backwards compatiblity with Prototype responses
				if ( this.results.extra_data != null ) {
					this.results.extra_data.error  =  this.results.error;
				}

				CW.Analytics.register_events( jsondata.analytics_events );

				if ( jsondata.extra_data ) {
					this.results.message_details  =  jsondata.extra_data.message_details;
				}

				if ( jsondata.error_fields ) {
					this.results.fields           =  jsondata.error_fields;
				}

				this.results.output           =  jsondata.output;
			}
			catch (e) {
				this.results.error         =  true;
				this.results.message       =  'Error processing json response: '+e;
				this.results.message_type  =  'error';
				return;
			}
		}

		// if error and extra_data is no_session tell the browser to reload the page to present the user with the login screen
		if ( this.results.error == 1 && this.results.extra_data == 'no_session' ) {
			top.location = '/';
		}

	},

	displayMessage:  function ( ) {

		if ( this.results.message == '' ) {
			return;
		}

		if ( ! this.options.show_message.apply( this ) ) {
			return;
		}

		var message_target  =  this.options.message_target;
		var mini_message    =  ( this.options.mini_message !== undefined ) ? this.options.mini_message : true;
		var message_opts    =  {
			append: false,
			message_target: message_target,
			clear_target: this.options.clear_target,
			mini_message: mini_message,
			message_details: this.results.message_details,
			duration: this.options.duration
		};

		new CW.Message(
			this.results.message,
			this.results.message_type,
			message_opts
		);
	},

	setFieldStyles: function( fields, container_css ) {

		fields = fields || [];

		container_css = container_css || '';
		CWjQuery( 'body' ).removeClass( 'errortext' );

		// error text
		for ( var i=0; i<fields.length; i++ ) {
			var field = fields[i];

			CWjQuery( container_css + ' #' + field.name ).addClass( 'errortext' );
			CWjQuery( container_css + '[name=' + field.name + ']' ).addClass( 'errortext' );
			CWjQuery( container_css + 'label[for=' + field.name + ']' ).addClass( 'errortext' );

			CWjQuery( container_css + ' #' + field.name + '_error_detail' ).html( field.error_detail );
			CWjQuery( container_css + ' .' + field.name + '_error_detail' ).html( field.error_detail );


		}

	},


	getTag:  function ( xml, tagName ) {
		var tags  =  xml.getElementsByTagName( tagName );

		/* Ignore zero-length tags array or text nodes */
		if ( tags.nodeType && tags.nodeType == 1 ) {
			return null;
		}

		return tags[0];
	},

	getTagContent:  function ( xml, tag ) {

		if ( typeof tag == 'string' ) {
			tag  =  this.getTag( xml, tag );
		}

		if ( tag ) {
			if ( tag.childNodes.length !== 0 ) {
				return tag.childNodes[0].nodeValue;
			}
			else {
				return '';
			}
		}

		return null;
	},
	
	getTagAttribute: function ( xml, tagName, attributeName ) {

		var tag        =  this.getTag( xml, tagName );
		if ( ! tag ) {
			return '';
		}

		var attribute  =  CWjQuery.makeArray(tag.attributes).find(
			function ( attributeObj ) {
				return attributeObj.nodeName == attributeName;
			}
		);

		if ( attribute ) {
			return attribute.value;
		}

		return '';
	 },

	convertPrototypeOptionsTojQuery: function ( options ) {

		// Prototype defaults to NOT replacing by default, whereas
		// jQuery default to replacing. So we specifically set to false
		// if nothing is specified.
		if ( ! options.hasOwnProperty( "replace" ) ) {
			options.replace = false;
		}
		else if ( options.replace == null ) {
			options.replace = false;
		}

		// Push the 'parameters' property into the root level of the options
		if ( options.hasOwnProperty( 'parameters' ) ) {

			if ( CWjQuery.type(options.parameters) == 'object' ) {

				params   =  options.parameters;
				for ( var key in params ) {

					// If the parameters were created using the $H Prototype function
					// the parameters will only have one key, named _object, that will
					// actually be the container of the properties we want to access.
					// It will also have a constructor named "klass", so we check for that
					// as well, just to make sure we have the correct scenario.
					// An example of this can be found in ace/js/product_attribute_group_setup.js
					if ( key == "_object" ) { 
						if ( options.parameters.constructor.name == "klass" ) {
							for( var subkey in params[key] ) {
								options[subkey] = params[key][subkey];
							}
							continue;
						}
					}

					options[key] = params[key];
				}
			}
			else if ( CWjQuery.type(options.parameters) == 'string' ) {

				// If the parameters are a string (like, a=1&b=2, etc), then we save those in
				// a reserved property for appending to the url later on, in CW.AjaxRequest.
				options.__querystring_params  =  options.parameters;
			}	

			delete options['parameters'];
		}

		// Map the 'method' property (get|post) to the boolean use_get
		options.use_get  =  false;
		if ( options.hasOwnProperty( 'method' ) && options.method == 'get' ) {
			options.use_get = true;
		}


		// Prototype onComplete callbacks expected two parameters, even though the first
		// parameter was not used the callback, by convention. So if we detect a callback
		// that takes two parameters, lets repackage it to take the one parameter that 
		// jQuery will give us, re-call the original callback with current_xhr as the first (unused) parameter
		if ( options.hasOwnProperty( 'onComplete' ) && options.onComplete != null ) {

			if ( options.onComplete.length == 2 ) {

				var previousFunction = options.onComplete;
				options.onComplete = CWjQuery.proxy( function ( result ) { 
						var response = { results: this.results, responseJSON: this.results };
						response.responseText  =  this.current_xhr.responseText;
						previousFunction( this.current_xhr, response );
					},
					this
				);
			}
			else if ( options.onComplete.length == 1 ) {

				// Some code only expected one parameter, so lets
				// enrich the response with responseJSON and responseText
				// and just pass that along to their handler.
				var previousFunction = options.onComplete;
				options.onComplete = CWjQuery.proxy( function ( result ) {
						var response = { results: this.results, responseJSON : this.results };
						response.responseText  =  this.current_xhr.responseText;
						previousFunction( response );
					},
 					this
 				);
			}
		}



		// Prototype has a onSuccess callback that jQuery does not have. If they have
		// this callback on their options, lets wrap that callback into the onComplete
		// handler. If there isn't an onComplete handler, we'll make one now.
		// onSuccess runs before onComplete, per the Prototype documentation here:
		// http://api.prototypejs.org/ajax/Ajax/Request/
		if ( options.hasOwnProperty( 'onSuccess' ) && options.onSuccess != null ) {

			var success = options.onSuccess;

			if ( ! options.hasOwnProperty( 'onComplete' ) || options.onComplete == null ) {
				options.onComplete  =  CWjQuery.proxy( 
						function ( result ) { 
							this.results.request = this.current_xhr;
							this.results.responseJSON = this.results;
							this.results.responseText = this.current_xhr.responseText;
							success( this.results );
						}, this
					);
			}
			else {
				var complete  =  options.onComplete;
				options.onComplete = CWjQuery.proxy( 
						function ( result ) { 
							this.results.request = this.current_xhr;
							this.results.responseJSON = this.results;
							this.results.responseText = this.current_xhr.responseText;
							success(this.results);
							complete(this.results);
						}, this
					);
			}
		}

		return options;
	}

} );


CW.Updater  =  CW.AjaxRequest.extend( {

	container : null,

	replace : true,

	init : function ( container, url, options ) {

		this.container = container;

		// If they gave us a string for the container, assume its
		// an element id and locate the element if we can.
		if ( typeof( this.container ) == typeof( "" ) ) {
			if ( ! this.container.indexOf( "#" ) == 0 ) {
				this.container = "#" + this.container;
			}
			this.container = CWjQuery(this.container);
			if ( ! this.container.length ) {
				Logger.log( 'Could not find the container object for id: ' + this.container, CW_LOG_ERROR );
			}
		}

		// If they gave us a raw html element for the container
		// we can take care of that here.
		if ( ! ( this.container instanceof CWjQuery ) ) {
			this.container  =  CWjQuery(this.container);
		}

		// Replace by default
		this.replace = ( options.replace === false ) ? false : true;

		this._super( url, options );
	},

	handleResponse : function ( jsondata, response_status, XHR ) {

		this.processResponse( jsondata, response_status, XHR );
		this.updateContent( this.results );
		this.displayMessage( );
		this.setFieldStyles( this.results.fields );

		CWjQuery(document).trigger(
			'cw.update',
			{
				container: this.container
			}
		);
	},

	updateContent:  function ( results ) {

		if ( results.error ) {
			return;
		}

		if ( ! this.container ) {
			return;
		}

		if ( this.replace ) {
			this.container.replaceWith( results.output );
		}
		else {
			this.container.html( results.output );
		}
	}
	
} );


/**
 * Use MultiUpdater when you want to update more than one panel in one ajax 
 * request.  The target page (url) should respond with a JSON array containing
 * targetted elements to replace as keys and the output to be replaced as the
 * value.
 *
 * Example:
 * array( 'container_div1' => 'Output',
 *        'container_div2' => 'More output' );
**/
CW.MultiUpdater  =  CW.Updater.extend ( {

	init:  function ( url, options ) {
		this._super( null, url, options );
	},

	updateContent:  function ( results ) {

		if ( results.error ) {
			return;
		}

		for ( var key in results.output ) {

			var receiver  =  CWjQuery('#' + key);

			if ( this.replace ) {
				receiver.replaceWith( results.output[key] );
			}
			else {
				receiver.html( results.output[key] );
			}
		}
	}
	
} );


/*
 * The following three classes exist to support the conversion from Prototype to jQuery.
 * There are two differences in the way the Prototpe classes work vs. the jQuery classes.
 *
 * 1. In the Prototype Clockwork.Ajax.Updater the default behavior was to
 * replace html content (Element.update), if no options was specified. 
 * In the jQuery version, CW.Updater, the default is to use jQuery.replaceWith
 * which replaces the element itself, as opposed to updating its inner html value.
 *
 * To migrate uses of the Prototype version of (Multi)Updater, we'll use the 
 * class below, CW.CompatibleUpdater (and MultiUpdater), which defaults to the Prototype
 * behavior of using jQuery.replaceWith. This saves us the trouble of having to
 * add a options.replace = false to all migrated uses.
 *
 * 2. The Prototype Updater had its form data parameters attached to the 'options'
 * object as a property named 'options.parameters'. In the jQuery Updater, the form
 * data parameters are on the root level of the object, i.e. 'options.form_value1'.
 *
 * Part of the convertPrototypeOptionsTojQuery function is to map the form data
 * from the 'options.parameters' property to the object's root level.
 *
 */
CW.CompatibleAjaxRequest  =  CW.AjaxRequest.extend ( {

	init : function ( url, options ) {

		options  =  this.convertPrototypeOptionsTojQuery( options );
		this._super( url, options );
	}

});


CW.CompatibleUpdater  =  CW.Updater.extend ( {

	init:  function ( container, url, options ) {
		options  =  this.convertPrototypeOptionsTojQuery( options );
		this._super( container, url, options );
	}

} );

CW.CompatibleMultiUpdater  =  CW.MultiUpdater.extend ( {

	init:  function ( url, options ) {
		options  =  this.convertPrototypeOptionsTojQuery( options );
		this._super( url, options );
	}

} );


CWjQuery.fn.Componentize  =  function ( callback ) {
	return CWjQuery( this ).each( function( ) {
		var id  =  this.id.replace( 'component_', '' );
		var c   =  new CW.ComponentOutput( { component_id : id } );
		if ( callback ) callback( c );
	} );
};



/**
 * CWjQueryClass encapsulating live-side js functionality for a component instance. 
 *
 * @author Lloyd Dalton <lloyd@clockwork.net>
 * 
**/


CW.ComponentOutput = CWjQueryClass.extend( {

	current_xhr : null,

	init: function ( args ) {

		this.component_id = args.component_id;

		this.component_el = args.component_el || CWjQuery('#component_'+this.component_id);
		this.minimessage_el = this.component_el.find( '.minimessage' );

		this.component_type = args.component_type;

		CWjQuery(window).load( CWjQuery.proxy( this.notify_components, this ) );

	},


	get_message_target : function() {

		if ( CWjQuery('#component_' + this.component_id + ' .minimessage').length > 0 )  {
			return '#component_' + this.component_id + ' .minimessage';
		}

		if ( CWjQuery('.message').length > 0 ) {
			return '.message';
		}
	},


	get_clear_target : function( ) {
		return '.message';
	},


	update : function( action, parms, onComplete ) {

		if ( this.updating ) {
			Logger.log( 'Update canceled - update already in progress.', CW_LOG_DEBUG );
			return false;
		}

		this.updating  =  true;

		parms = this.prepare_update_parms( action, parms, onComplete );

		// By default, update the entire component.
		var container = parms.container || this.component_el;

		this.update_start( parms );

		url = parms.url || removeAllActionParameters( location.href );

		var updater = new CW.Updater( container, url, parms );

		if ( parms.updateContent ) {
			updater.updateContent  =  parms.updateContent;
		}

		this.current_xhr = updater.current_xhr;
	},


	// Separate function for easy overriding
	prepare_update_parms : function( action, parms, onComplete ) {

		parms = parms || {};

		parms['action_' + this.component_id] = action;

		parms.message_target = parms.message_target || this.get_message_target();
		parms.clear_target   = parms.clear_target   || this.get_clear_target();

		onComplete  =  onComplete || function() {};

		var updateComplete = function( results ) {

			this.update_end( parms );

			this.updating = false;

			onComplete( results );
		};

		parms.onComplete = CWjQuery.proxy( updateComplete, this );

		return parms;
	},


	update_start : function( parms ) {
		var container = parms.container || this.component_el;

		if ( parms.cover_el && parms.cover_el.length > 0 ) {
			// If a cover_el is suplied, fade it in
			parms.cover_el.css({ 'opacity': 0.2 });
			parms.cover_el.show();
			parms.cover_el.fadeTo( 'slow', 0.7 );
		}
		else {
			// Otherwise, fade the container out 
			container.fadeTo( 'slow', 0.2 );
		}
	},


	update_end : function ( parms ) {
		var container = parms.container || this.component_el;

		if ( parms.cover_el && parms.cover_el.length > 0 ) {
			parms.cover_el.fadeOut( 'slow' );
		}
		else {
			container.fadeTo( 'fast', 1.0 );
		}
	},


	post_json_data : function ( action, params, onComplete ) {

		params = this.prepare_post_json_data_params(
			action,
			params,
			onComplete
		);

		url = params.url || removeParameter(
			location.href,
			'action_' + this.component_id
		);

		var request = new CW.AjaxRequest( url, params );

		this.current_xhr = request.current_xhr;

		return request.current_xhr;
	},


	prepare_post_json_data_params : function( action, params, onComplete ) {
		params = params || {};

		params['action_' + this.component_id] = action;
		params.json = 1;

		params.message_target = params.message_target || this.get_message_target();
		params.clear_target   = params.clear_target   || this.get_clear_target();

		onComplete  =  onComplete || function() {};

		var complete = function( results ) {

			this.notify_components( );

			results.component_el = this.component_el;
			results.component_id = this.component_id;
			results.component_object = this;
			onComplete( results );
		};

		params.onComplete = CWjQuery.proxy( complete, this );

		return params;
	},


	/**
	 ** Override notify_components in subclasses which need to pass information
	 * to other component objects on a page.
	 *
	 * This is often done at page load 
	 * and onComplete following an ajax request.
	 *
	 * Example:
	 *
		friend_components = CW.ComponentOutput.get_page_components( 'FriendComponentOutput' );

		for ( var i = 0; i< friend_components.length; i++ ) {
			friend_components[i].friend_function( "new data from me!" );
		}
	 *
	 *
	 * * @author Lloyd Dalton <lloyd@clockwork.net>
	 * * 
	 * * @param   void 
	 * * @return  void
	 ***/

	notify_components : function () {
	},


	/**
	 ** Stores a reference to the component in a globally-available 
	 *
	 * * @author Lloyd Dalton <lloyd@clockwork.net>
	 * * 
	 * * @param   mixed  $changeme
	 * * @return  void
	 ***/

	register : function( classname ) {

		// Component id lookup table
		CW.ComponentOutput.instances['c_'+this.component_id] = this;


		// Component type lookup table
		if ( ! CW[classname].instances ) {
			CW[classname].instances = {};
		}

		CW[classname].instances['c_'+this.component_id] = this;

	}
});


CW.ComponentOutput.instances = {};


CW.ComponentOutput.get_page_components = function( type ) {

	results = [];

	if ( ! CW[type] ) {
		return results;
	}

	for ( var c in CW[type].instances) {
		results.push( CW[type].instances[c] );
	}

	return results;
};


/**
 * memorizes the starting values of the inputs in a form element
 * for later use by reset_form_inputs
 *
 * easiest way is to add something like the following to your init:
 *

	form_walker  =  function( index, form_el ) {
		CW.memorize_form_for_reset( form_el );
	}

	CWjQuery.each( CWjQuery( 'form' ), CWjQuery.proxy( form_walker, this ) );

 *
 *
 * * @author Matt Gray <matt@clockwork.net>
 * * @author Drew A. Stevenson <das@clockwork.net>
 * * 
 * * @param   form element  form_el
 * * @return  void
**/

CW.memorize_form_for_reset = function ( form_el ) {

	input_els  =  CWjQuery( form_el ).find( ':input' );

	CWjQuery.each( input_els, function ( index, el ) {

		jel  =  CWjQuery( el );

		if ( jel.is(':radio') || jel.is(':checkbox') ) {
			jel.data( 'reset_val', jel.prop( 'checked' ) );
		}
		else {
			jel.data( 'reset_val', jel.val( ) );
		}

	} );
}

/**
 * resets the default values on a form el 
 *
 * @author Drew A. Stevenson <das@clockwork.net>
 * 
 * @param   form element  form_el
 * @return  void
**/

CW.reset_form_inputs = function ( form_el ) {

	var form_inputs  =  form_el.find( ":input" );

	CWjQuery.each( form_inputs, function( index, input_el ) {

		jinput_el  =  CWjQuery( input_el );

		var reset_val  =  jinput_el.data( 'reset_val' );

		if ( jinput_el.is(":checkbox") || jinput_el.is(":radio") ) {

				jinput_el.prop( 'checked', reset_val );

		}
		else {
			jinput_el.val( reset_val );
		}

	} );

	return true;
}

CW.Page = {
	is_preview : function ( ) {

		// Check to see if we're in preview so that we load the JSON via ajax
		if ( document.location.href.match( '/shared/content/preview_content.php' ) ) {
			return true;
		}

		return false;
	}
};

CW.Navigation = {};

CW.Navigation.JSON = {

	tree : { },
	lookup : { },
	map : { },
	cache : { },
	root_id : null,
	page_id : null,

	// These will be reverse looked up from the map
	ancestry_key : null,
	exclude_from_nav_key  :  null,
	order_key : null,

	// These get added to the new array as its built
	children_key : 'children',
	page_id_key : 'site_page_id',

	/**
	 * Load the json navigation object whether in preview or live side. Pass 
	 * in the cache buster string if publish to let the browser cache based
	 * on the last publish time.
	 *
	 * @param  string  nav_abbr       String of nav_abbr being loaded
	 * @param  string  cache_buster   Template variable that should be 
	 *                                available in templates
	 * @returns  promise 
	**/
	load : function ( nav_abbr, cache_buster ) {

		var data = {}, filename;

		// Check to see if we're in preview so that we load the JSON via ajax
		if ( CW.Page.is_preview( ) ) {
			filename  =  document.location.href;
			data  =  { 
				'nav_abbr'  :  nav_abbr, 
				'action'    :  'get_json_navigation' 
			};
		}
		else {

			if ( cache_buster ) {
				cache_buster  =  '?' + cache_buster;
			}
			else {
				cache_buster  =  '';
			}

			filename      =  '/include/navs/' + nav_abbr + '/nav.json' + cache_buster;
		}

		var promise  =  CWjQuery.ajax( filename, { 'data': data, dataType: 'json' });

		promise.done( function( data ) {

			CW.Navigation.JSON.tree    =  data.tree;
			CW.Navigation.JSON.lookup  =  data.lookup;
			CW.Navigation.JSON.map     =  data.map;

			// Set the key names being used for these attributes
			CW.Navigation.JSON.ancestry_key          =  data.map['ancestry'];
			CW.Navigation.JSON.exclude_from_nav_key  =  data.map['exclude_from_nav'];
			CW.Navigation.JSON.order_key             =  data.map['order'];

			for ( var id in data.tree ) {
				if ( id != CW.Navigation.JSON.order_key ) {
					CW.Navigation.JSON.root_id   =  id;
					break;
				}
			}
		});

		return promise;
	},


	/**
	 * Get the navigation to be used for a given page. Handles pruning of pages
	 * that are excluded from nav except those that are parents, children or
	 * siblings of the page being requested.
	 *
	 * Multiple requests may be made for the same page and will be cached.
	 *
	 * @param    page_id  ID of page being rendered
	 * @returns  object
	**/
	get : function ( page_id ) {
		var level = 0;

		// Check for page existance
		if ( ! this.lookup[page_id] ) {
			return false;
		}

		this.page_id  =  page_id;

		// So that we can make multiple requests for the same page node 
		// without recalculating but calls to other nodes can also be made 
		// without corrupting page tree data.
		if ( ! this.cache[this.page_id] ) {
			this.cache[this.page_id]  =  this.get_branch( this.root_id, this.tree[this.root_id], level );
		}

		return this.cache[this.page_id];
	},


	/**
	 * Function that recursively iterates through page tree.
	 *
	 * @params    int     page_id    ID of current node
	 * @params    object  page_tree  page tree of current branch
	 * @params    int     level      Current level of tree
	 *
	 * @returns   object
	**/
	get_branch : function ( page_id, page_tree, level ) {

		var next_level      =  level + 1,
		    next_page_tree  =  page_tree[page_id],
		    branch          =  [];
		
		branch                    =  this.decorate_page( page_id );
		branch[this.page_id_key]  =  page_id;


		if ( ! next_page_tree ) {
			next_page_tree  =  [];
		}

		for ( var key in page_tree[this.order_key] ) {

			var id  =  page_tree[this.order_key][key];

			// If the page we're actively requesting is exluded from nav, we 
			// want to keep parents, siblings and children in the nav structure
			if ( this.hide_from_nav( id ) ) {
				continue;
			}

			if ( ! branch[this.children_key] ) {
				branch[this.children_key]  =  [];
			}
			branch[this.children_key].push( this.get_branch( id, page_tree[id], next_level ) );
		}

		return branch;
	},


	/**
	 * Get the page details for a given page.
	 *
	 * @param    page_id  ID of page being rendered
	 * @returns  object
	**/
	page : function ( page_id ) {
	    if ( ! this.lookup[page_id] ) {
			return false;
		}
		return this.map_attributes( this.lookup[page_id] );
	},


	/**
	 * Figure out if the page being evaluated should be hidden in the structure
	 * because it's excluded from nav and we're not on it or a 
	 * sibling/child, etc
	 *
	 * @params    int     page_id    ID of page being evaluated
	 * @returns   boolean
	**/
	hide_from_nav : function ( page_id ) {

		if ( ! this.lookup[page_id] ) {
			return true;
		}

		var requested_page  =  this.lookup[this.page_id],
		    page            =  this.lookup[page_id];

		if ( page[this.exclude_from_nav_key] ) {

			// If the requested page IS the page we're testing against
			if ( page_id == this.page_id ) {
				return false;
			}

			// If the page we're testing against is a child (as long as it's
			// not the root of the tree because everything is a child of that!)
			// OR the page being requested is the child of the page were 
			// iterating over.
			if ( this.page_id != this.root_id 
			&& ( page[this.ancestry_key].indexOf( this.page_id ) >= 0 
			||   requested_page[this.ancestry_key].indexOf( page_id ) >= 0 ) ) {
				return false;
			}

			return true;
		}

		return false;
	},


	/**
	 * Page hash decorator to add the nice active/parent/current and any other
	 * future niceities. This function also calls the reverse attribute mapping
	 * function so that the abbreviated keys are replaced with the standard
	 * attribute names, eg n => page_name.
	 *
	 * @param    int     page_id  ID of page being decorated
	 * @returns  object  
	**/
	decorate_page : function ( page_id ) {
		var page            =  this.map_attributes( this.lookup[page_id] ),
		    requested_page  =  this.lookup[this.page_id];

		if ( requested_page[this.ancestry_key].indexOf( page_id ) >= 0 ) {
			page['parent']   =  true;
			page['active']   =  true;
		}

		if ( this.page_id == page_id ) {
			page['current']  =  true;
			page['active']   =  true;
		}

		return page;
	},


	/**
	 * Remap data in structure from single letter keys to full attribute names
	 *
	 * @params   object   page   Hash of page to remap
	 * @returns  object   
	**/
	map_attributes : function ( page ) {
		var new_page = {};

		for ( var key in this.map ) {
			var value =  this.map[key];
			if ( value && page[value] ) {
				new_page[key]  =  page[value];
			}
		}

		return new_page;
	}

};

// Instantiates a generic ComponentOutput object and optionally calls a method on it
CWjQuery.fn.Componentize  =  function ( callback ) {
	return CWjQuery( this ).each( function( ) {
		var id  =  this.id.replace( 'component_', '' );
		var c   =  new CW.ComponentOutput( { component_id : id } );
		if ( callback ) callback( c );
	} );
};

// Automatically initialize jquery js components for the ones that support it.
//
// To support dynamic creation, include at least the following in the div wrapper for your component:
// <div class="auto_init" data-component_id="$component_id" data-component_type="$component_type">
//
// Any custom data attributes added to your component are included in the call to 'init' for the object.
//
// You may also optionally choose to initialize your component based on a custom event by using the 
// following attributes.
//     data-auto_init_element:  The element to attach the event handler to. Optional. Default is the component.
//     data-auto_init_selector: The selector to filter descendants of the element. Optional.
//     data-auto_init_events:   The events that trigger auto_init
CWjQuery( function( $ ) {
	$( 'div.auto_init, div.auto-init' ).each( function( i, el ) { 
		var $this  =  $( this ),
			type   =  $this.data( 'component_type' );

		if ( ! type ) {
			Logger.log( "data-component_type attribute is required.", CW_LOG_DEBUG );
			return;
		}

		var class_name  =  type.toCamelCase( ) + 'ComponentOutput';

		if ( ! CW[ class_name ] ) {
			Logger.log( "Could not find component " + class_name, CW_LOG_DEBUG );
			return;
		}

		var create  =  function( ) {
			var data = $this.data( );
			data['component_el'] = $this;
			var c  =  new CW[ class_name ]( data );
			c.register( class_name );
		};

		var init_events    =  $this.data( 'auto_init_events' );

		if ( init_events ) { // Attach creation as a custom event handler
			var init_el        =  $this.data( 'auto_init_element' ) || $this;
			var init_selector  =  $this.data( 'auto_init_selector' );
			CWjQuery( init_el ).one( init_events, init_selector, create );
		} else { // No custom event specified. Just create it.
			create( );
		}
	} );
} );


/**
 * Determines if an AJAX request is in progress, takes request.transport as the argument
 * Used in Ajax.Responders
*/
CW.request_in_progress = function ( xmlhttp ) {
	
	switch ( xmlhttp.readyState ) {
		case 1:
		case 2: 
		case 3:
			return true;
			break;
		// Case 4 and 0
		default:
			return false;
			break;
	}
	
};


CW.escape_single_value  =  function ( value ) {
	// prototype used the escapeHTML function in Prototype, which just
	// does the following string replacements.
	return value.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace( /"/g,'&quot;' );
}


/** 
 * CharacterCount for "X characters remaining" indicators. 
 *
 * @author Lloyd Dalton <lloyd@clockwork.net>
**/

CW.CharacterCount  =  function ( properties ) {

	this.max_chars   =  properties.max_chars | 140;
	this.input_el    =  properties.input_el;
	this.display_el  =  properties.display_el;

	// Sanity check
	if ( ! this.input_el || ! this.display_el ) {
		return;
	}

	var obj = this;
	this.input_el.on( 'keyup', function ( ) { obj.update_count( ); } );
	this.input_el.on( 'change', function ( ) { obj.update_count( ); } );
	this.update_count( );
}


CW.CharacterCount.prototype  =  {

	update_count : function( ) {

		// Sanity check
		if ( ! this.input_el || ! this.display_el ) {
			return;
		}

		this.display_el.text( this.max_chars - this.input_el.val( ).length );
	}

}


CW.SmartDate = function ( args ) {

	// valid args: include_time (boolean) - true by default. If false, only MM-DD-YYYY dates will be shown (no times)
	//             preserve_blank (boolean) - false by default. If true, will not attempt to parse blank dates 

	// Sanity check
	if ( ! args.input_el ) {
		return;
	}

	args.include_time     =  (args.include_time    != null) ? args.include_time    : true;  // include time by default
	args.preserve_blank   =  (args.preserve_blank  != null) ? args.preserve_blank  : false; // don't preserve blanks by default
	args.include_seconds  =  (args.include_seconds != null) ? args.include_seconds : false; // don't include seconds by default
	args.set_to_eod       =  (args.set_to_eod      != null) ? args.set_to_eod      : false; // don't set to end of day by default

	args.input_el.on( 'change', function ( evt ) {
		if ( args.preserve_blank && args.input_el.value == '' ) {
			return;
		}

		var d = Date.parse(args.input_el.value);

		if ( d != null ) {

			// If the "end of day" flag is set, and no explicit time value is present (as indicated by the absence of a ":"),
			// and the computed time is "12:00:00 am" (the default), then force the time to the end of the day, i.e. "11:59:59 pm".
			// Another way of putting this is that if the user adds or changes a datetime field that the EOD flag is set for,
			// and they don't specify any time, then the time is automatically set to the last second of the date
			// that was specified.  This is useful for "end time" fields, in which users often enter just a date
			// assuming that means the entire day.
			if ( args.set_to_eod &&
				 args.input_el.value.indexOf(":") < 0 &&
				 CW.SmartDate.is_default_time( d ) ) {

				d.setHours(23);
				d.setMinutes(59);
				d.setSeconds(59);
			}

			args.input_el.value = CW.SmartDate.format_date(d, args);
		}

		if ( typeof args.callback != "undefined" ) {
			args.callback( );
		}

	});

};

CW.SmartDate.is_default_time = function ( date ) {

    if ( ! date instanceof Date  ||
           date  ==  null ) {
        return true;
    }
    if (date.getHours( )    ==  0       &&
        date.getMinutes( )  ==  0       &&
        date.getSeconds( )  ==  0 ) {
            return true;
    }
    return false;
}


CW.SmartDate.format_date = function(d, args) {
	var include_time     =  args.include_time != null ? args.include_time : true;
	var date_format      =  args.date_format;
	var include_seconds  =  args.include_seconds;
	var raw_input        =  args.input_el.value;
	var use_format       =  null;

	if ( date_format ) {
		use_format  =  date_format;
	}
	else if ( include_time ) {
        if ( include_seconds ) {
            use_format  =  CW.config.datetime_with_seconds_format;
        }
        else {
            use_format  =  CW.config.datetime_format;
        }
	}
	else {
		use_format  =  CW.config.date_format;
	}

	var dateString = null;

	// If the use format is a function, get the actual format
	// by passing the raw input to the function
	if ( use_format instanceof Function ) {
		use_format  =  use_format( raw_input );
	}

	if ( ! include_time ) {
		dateString = d.toString( use_format );
	}
	else {
		dateString = d.toString( use_format ).replace( /AM/, 'am' ).replace( /PM/, 'pm' ); // php wants lowercase am-pm strings
	}

	return dateString;
}


// valid args: ignore_crap(boolean) - true by default.  If false, invalid dates in the input field will prevent the popup from displaying.  It will shake its little head and stubbornly refuse.
//             preserve_blank (boolean) - false by default.  If true, will not attempt to parse blank dates 
CW.PopupCalendar = function( args ) {

	args : null;
	args.preserve_blank   = (args.preserve_blank   != null) ? args.preserve_blank  : false; // dont preserve blanks by default
	args.set_to_bod       =  (args.set_to_bod      != null) ? args.set_to_bod      : false; // don't set to beginning of day by default
	args.set_to_eod       =  (args.set_to_eod      != null) ? args.set_to_eod      : false; // don't set to end of day by default

	if ( args ) {
		this.add(args);
	}
}

CW.PopupCalendar.prototype = {

	add : function( args ) {

		this.args  = args;
		if ( args.ignore_crap == null ) args.ignore_crap = true;

		var input_el  =  args.input_el;

		// Sanity check
		if ( ! input_el ) {
			return;
		}

		var close_handler  =  CWjQuery.proxy( function(dateText, calendar) { this.calendar_closed(dateText, calendar ); }, this );
		CWjQuery(input_el).datepicker( { 
			onClose: close_handler, 
			showOn: "button", 
			buttonImage: "/images/buttons/calendar.png", 
			buttonImageOnly: true,
			constrainInput: false
		});

		// Get the button that jQuery-ui made for us so we can tweak it to look better
		var btn_img = CWjQuery( input_el ).siblings( '.ui-datepicker-trigger' ).first( );


		if ( args.inside ) {
			// Fits the button inside the text field
			input_el.setStyle( {
				'paddingRight':  '22px',
				'marginRight' :  '-22px'
			} );
		}

		var span_class  =  args.inside ? 'smart-date-button inside' : 'smart-date-button';
		var span_el = CWjQuery( "<span class='" + span_class + "'></span>" );
		span_el.insertAfter(input_el);

		btn_img.css( 'margin-left', '4px' );
		btn_img.css( 'vertical-align', 'middle' );
		btn_img.css( 'cursor', 'pointer' );
		btn_img.insertAfter(span_el);

		// on init, parse the contents of the date fields
		var d = null;
		if ( args.date ) {
			d = args.date;
		} 
		else {
			// blank value -> today
			if ( input_el.value === '') {
				if ( ! args.preserve_blank ) { 
					d = (0).seconds().fromNow();

					if ( input_el.disabled != true ) {
						input_el.value = CW.SmartDate.format_date(d, args);
					}
				}
			} 
			else { // non-blank date, attempt to parse
				d = Date.parse(input_el.value);

				if (d === null) { // parse failed, set calendar date to current date, but don't replace input
					d = (0).seconds().fromNow();
				} 
				else {
					if ( input_el.disabled != true ) {
						input_el.value = CW.SmartDate.format_date(d, args);
					}
				}
			}
		}

		
	},
	
	
	denial_shake : function( el ) {
		CWjQuery(el).effect( "shake" );
	},
	
	calendar_closed:  function ( dateText, calendar ) {

		var previous_date  =  Date.parse( CWjQuery(this.args.input_el).val( ) );

		var selected_date  =  Date.parse(dateText);

		if ( this.args.preserve_blank && selected_date == null ) {
			return;
		}

		selected_date.setHours( new Date().getHours( ) );
		selected_date.setMinutes( new Date().getMinutes( ) );
		selected_date.setSeconds( 0 );

		if ( ( this.args.set_to_bod  ==  true )  &&  CW.SmartDate.is_default_time( previous_date ) ) {
			selected_date.setHours(0);
			selected_date.setMinutes(0);
			selected_date.setSeconds(0);
		}
		else if ( ( this.args.set_to_eod  ==  true )  &&  CW.SmartDate.is_default_time ( previous_date ) ) {
			selected_date.setHours(23);
			selected_date.setMinutes(59);
			selected_date.setSeconds(59);
		}

		// initially set the value to the full date time format
		this.args.input_el.value = selected_date.toString( CW.config.datetime_format );

		// now format based on user preferences
		this.args.input_el.value = CW.SmartDate.format_date(selected_date, this.args);

		if ( typeof this.args.callback != "undefined" ) {
			this.args.callback( Date.parse(dateText) );
		}
	}


}


CW.PopupDateRange = function( start_id, end_id, args ) {

	var start_id_selector = '#' + start_id;
	var end_id_selector = '#' + end_id;

	if ( CWjQuery( start_id_selector ) && CWjQuery( end_id_selector ) && args ) {
		
		this.args  =  args;

		var clone  =  function ( o ) { 
			var copy  =  {};
			for ( var i in o ) {
				copy[i]  =  o[i];
			}
			return copy;
		};

		this.start_args           =  clone( args );
		this.start_args.input_el  =  CWjQuery( start_id_selector );
		
		this.end_args             =  clone( args );
		this.end_args.input_el    =  CWjQuery( end_id_selector );

		this.create( );
	}
}

CW.PopupDateRange.prototype = {

	create  :  function( ) {
		this.start_calendar  =  new CW.PopupCalendar( this.start_args );
		this.start_smart     =  new CW.SmartDate( this.start_args );

		this.end_calendar    =  new CW.PopupCalendar( this.end_args );
		this.end_smart       =  new CW.SmartDate( this.end_args );
	},

	set_smart  :  function( d ) {
		var start_date  =  CW.SmartDate.format_date(d, this.args);
		var end_date    =  CW.SmartDate.format_date(date(), this);
		this.set( start_date, end_date );
	},

	set  :  function( start, end ) {
		this.start_args.input_el.value  =  start;
		this.end_args.input_el.value    =  end;
	}

}


CW.Chart  =  {

	data: {},

	default_width: '100%',

	retry_limit: 5,

	retry_delay: 500,

	retries: [],

	default_height: 175,

	flash_version: '9.0.0',

	ofc_swf_url:  '/shared/swf/open-flash-chart.swf',

	add: function ( id, args ) {

		if ( ! window.swfobject ) {
			Logger.log( 'CW.Chart.add: swfobject not available!', CW_LOG_ERROR );
			return false;
		}


		args.width   =  args.width  || CW.Chart.default_width;
		args.height  =  args.height || CW.Chart.default_height;

		// Set up initial (empty) data set
		CW.Chart.data[id]  =  {};

		// Set up the getter function
		var getter_fn  =  function ( ) {

			if ( ! CW.Chart.data[id] ) {
				Logger.log( 'CW.Chart: Getter for missing chart ID `' + id + '\' called', CW_LOG_ERROR );
				return '{}';
			}

			return JSON.stringify( CW.Chart.data[id] );
		};

		// Add the getter function to window
		window['clockwork_get_chart_data_' + id]  =  getter_fn;

		var swfObj  =  window.swfobject;

		// Set up the embed function
		var embed_fn  =  function ( ) {

			// Getter (unfortunately) must live in the window's scope
			var flashvars    =  { 'get-data': 'clockwork_get_chart_data_' + id,
								  'id'      : id };
			var params       =  { 'wmode': 'transparent' };
			var attributes   =  { };
			var install_url  =  null;

			swfObj.embedSWF( CW.Chart.ofc_swf_url, id, args.width, args.height,
						CW.Chart.flash_version, install_url,
						flashvars, params, attributes );
		};

		// Add the embed function to the window's load event
		CWjQuery(window).load( embed_fn );

		return true;
	},

	refresh: function ( id ) {

		var chart  =  CWjQuery( '#' + id );

		if ( ! chart.length ) {
			Logger.log( 'CW.Chart.refresh: Cannot find chart DIV ID `' + id + '\'', CW_LOG_ERROR );
			return false;
		}

		// Chart not ready yet, try again in a little bit if we haven't tried too many times already
		if ( ! chart[0].load ) {
			Logger.log( 'CW.Chart.refresh: Chart ID `' + id + '\' not yet loaded', CW_LOG_DEBUG );
			var retries  =  CW.Chart.retries[ id ] || 0;
			if ( retries < CW.Chart.retry_limit ) {
				CW.Chart.retries[ id ]  =  retries++;
				window.setTimeout( function( ) { CW.Chart.refresh( id ); }, CW.Chart.retry_delay );
			}
			return false;
		}

		var json_data  =  JSON.stringify( CW.Chart.data[id] );
	 	chart[0].load( json_data );
		return true;
	},

	update: function ( id, data ) {

		CW.Chart.data[id]  =  data;
		CW.Chart.refresh( id );

		return true;
	}
}

// ofc_ready is an Open Flash Chart hook called when the SWF has finished 
// loading
window.ofc_ready  =  function ( ) {

	for ( var chart_id in CW.Chart.data ) {

		var chart  =  CWjQuery( '#' + chart_id );

		if ( ! chart.length ) {
			Logger.log( 'ofc_ready: Could not find activated chart id `' + chart_id + '\'', CW_LOG_ERROR );
			return;
		}

		// Hack to force a resize, fixes glitches with Y-axis display
		chart.width( '99%' );
		chart.width( '100%' );
	}
}


/* Spinner for "saving..." state indicators. 
 *
 * @author Lloyd Dalton <lloyd@clockwork.net>
 */
CW.Spinner  =  function(el, properties) {

	if ( properties == 'unspin' ) {
		this.unspin ( )
		return;
	}

	var text = properties.text || 'Spinning...';

	this.image = (properties['image']) ? properties['image'] : '/images/indicator.gif'; // spinner image

	if ( properties.append ) {
		this.spin_element = el.insert( new Element( 'span' ), {position : 'after'} ).down();
		this.spin_element = CWjQuery('<span></span>');
		this.spin_element.insertAfter( el );
	}
	else {
		this.spin_element = el;
	}

	this.spin_element_contents = null;
	this.spin_contents = this.spin_element.html( );
	this.spin_element.previous_contents = this.spin_contents;
	this.spin_element.html( '<img class="spinner" src="'+this.image+'">'+text );
}

CW.Spinner.prototype  =  {

    unspin : function( ) {
		this.spin_element.html( '' );
		this.spin_element.html( this.spin_contents );
    }
}

/* Simple tab switching
 * based on http://tetlaw.id.au/view/blog/fabtabulous-simple-tabs-using-prototype/
 *
 * @author Lloyd Dalton <lloyd@clockwork.net>
 */
CW.Tabs  =  function (element) {

	this.element = CWjQuery('#' + element);
	this.menu = this.element.find('a');
	var obj = this;
	this.menu.each( function ( index, value ) { obj.hide(value); } );
	this.show(this.getInitialTab());
	this.menu.each( function( index, value ) { obj.setupTab( value ); } );
}

CW.Tabs.prototype  =  {

	setupTab : function(el) {
		var obj = this;
		CWjQuery(el).parent( ).first( ).on( 'click', function ( event ) { obj.activate( event, this ); } );
	},

	activate :  function(event, li_el) {
		if ( ! li_el ) {
			li_el = CWjQuery(event.target).closest("li");
		}

		var el = CWjQuery(li_el).children( ).first( );

		if  ( event != null ) {
			event.preventDefault( );
		}

		this.show(el);

		var obj = this;
		this.menu.each( function ( index, value ) { 
			if ( obj.tabID(value) == obj.tabID(el) ) { return; }
			obj.hide(value);
		});

	},

	hide : function(el) {
		CWjQuery(el).parent( ).first( ).removeClass('active-tab');
		var tabId = '#' + this.tabID(el);
		CWjQuery(tabId).removeClass('active-tab-body');
		CWjQuery(tabId).hide();
	},

	show : function(el) {
		CWjQuery(el).parent( ).first( ).addClass('active-tab');
		var tabId = '#' + this.tabID(el);
		CWjQuery(tabId).addClass('active-tab-body');
		CWjQuery(tabId).show();
	},

	tabID : function(el) {
		var tabId = CWjQuery(el).attr('href').match(/#(\w.+)/)[1];
		return tabId;
	},

	getInitialTab : function() {
		if (document.location.href.match(/#(\w.+)/)) {
			var loc = RegExp.$1;
			var foundIndex = -1;
			this.menu.each( function( index, el ) { 
				if ( CWjQuery(el).attr('href').match(/#(\w.+)/)[1] == loc ) { foundIndex =  index; }
			});
			if ( foundIndex > - 1 ) { return this.menu[foundIndex]; }
		} 

		return this.menu.first();
	}
	
};

CW.Effect = { };

CW.Effect.options   =  { duration: 750, queue:true };

CW.Effect.BlindDown  =  function ( id ) {
	CWjQuery( '#' + id ).slideDown( CW.Effect.options );
};

CW.Effect.BlindUp  =  function ( id ) {
	CWjQuery( '#' + id ).slideUp( CW.Effect.options );
};

CW.Effect.BlindToggle  =  function ( id ) {
	CWjQuery( "#" + id ).slideToggle( CW.Effect.options );
};

CW.Effect.BlindRemove  =  function ( id ) {
	CW.Effect.BlindUp( id );
	setTimeout( function ( ) { CWjQuery('#'+id).remove( ); }, CW.Effect.options.duration + 50 );
};
